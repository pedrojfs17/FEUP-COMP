options 
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(JmmParser)

import java.io.FileInputStream;
import java.util.HashMap;

public class JmmParser {

    public static HashMap<String, Integer> var = new HashMap<String, Integer>();
    public static void main(String[] args) throws ParseException {
        System.out.println("Parser for a file.");
        System.out.println("Write a file name");
        try{
            FileInputStream file = new FileInputStream("test/public/java/HelloWorld");
            JmmParser parser = new JmmParser(file);
            SimpleNode root = parser.Program();

            root.dump("");
            System.out.println("Parsed.");
        } catch (Exception e) {
            System.out.println("Couldn't parse file");
            e.printStackTrace();
        }

    }

}

PARSER_END(JmmParser)

SKIP : 
{
    " " | "\t" | "\n" | "\r" | <"//"(~["\r","\n"])*> | <"/*">: MLCOMMENT
}

<MLCOMMENT> SKIP :
{
    <"*/"> : DEFAULT
    | <~[]>
}

TOKEN : 
{
    <INTEGERLITERAL : (["+","-"])?(["0" - "9"])+ >
    | <IMPORT: "import">
    | <CLASS: "class">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <EXTENDS: "extends">
    | <RETURN: "return">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <ELIF: <ELSE> <IF>>
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <SOUT: "System.out.println">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <LENGTH: "length">
    | <LBRACKET: "{">
    | <RBRACKET: "}">
    | <LPARENTHESES: "(">
    | <RPARENTHESES: ")">
    | <LSQUAREBRACKET: "[">
    | <RSQUAREBRACKET: "]">
    | <COLON: ",">
    | <SEMICOLON: ";">
    | <DOT: ".">
    | <MINUS: "-">
    | <ADD: "+">
    | <EQ : "=">
    | <MULT: "*">
    | <DIV: "/">
    | <LESS: "<">
    | <EXCLAMATION: "!">
    | <AND: "&&">
    | <IDENTIFIER: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])*>
}

SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration(): {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER> )* <SEMICOLON>)*
}

void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>]
    <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACKET>
}

void MethodDeclaration(): {}
{
    <PUBLIC> (MainDeclaration() | OtherMethodDeclaration())
}

void MainDeclaration(): {}
{
    <STATIC> <VOID> <MAIN> <LPARENTHESES> <STRING> <LSQUAREBRACKET> <RSQUAREBRACKET> <IDENTIFIER> <RPARENTHESES> <LBRACKET>
    (VarDeclaration())*
    (Statement())* <RBRACKET>
}

void OtherMethodDeclaration(): {}
{
    Type() <IDENTIFIER> <LPARENTHESES> [Type() <IDENTIFIER> (<COLON> Type() <IDENTIFIER> )*] <RPARENTHESES> <LBRACKET>
    (VarDeclaration())*
    (Statement())*
    <RETURN> ExpressionAndMin() <SEMICOLON> <RBRACKET>
}

void VarDeclaration(): {Token t;}
{
    Type() t=<IDENTIFIER>#IDENTIFIER <SEMICOLON>
}

void Type(): {Token t;}
{
     (t=<INT>#INT) (<LSQUAREBRACKET> <RSQUAREBRACKET>#ARRAY)?
    | t=<BOOLEAN>#BOOLEAN
    | t=<IDENTIFIER>#IDENTIFIER
}

void Statement(): {Token t;}
{
    <LBRACKET> (Statement())* <RBRACKET> #BODY
    | <IF> <LPARENTHESES> ExpressionAndMin() <RPARENTHESES> Statement() <ELSE> Statement() #IFELSE
    | <WHILE> <LPARENTHESES> ExpressionAndMin() <RPARENTHESES> Statement() #ELSE
    | ExpressionAndMin() <SEMICOLON> #DECLARATION
    | <IDENTIFIER> StatementAssignment() #ASSIGNMENT
}

void StatementAssignment(): {Token t;}
{
     <EQ> ExpressionAndMin() <SEMICOLON> #SIMPLEASSIGNMENT
     |  <LSQUAREBRACKET> ExpressionAndMin() <RSQUAREBRACKET> <EQ> ExpressionAndMin() <SEMICOLON> #ARRAYASSIGNMENT
}

// Operations
void ExpressionAndMin(): {Token t;}
{
    ExpressionAddSub()
    (   <AND> ExpressionAddSub() #AND(2)
    | <LESS> ExpressionAddSub() #LESS(2))?

}

void ExpressionAddSub(): {Token t;}
{
    ExpressionMultDiv()
    (   <ADD> ExpressionMultDiv() #ADD(2)
    | <MINUS> ExpressionMultDiv() #SUB(2))?
}

void ExpressionMultDiv(): {Token t;}
{
    ExpressionArray()
    (   <MULT> ExpressionArray() #MULT(2)
    | <DIV> ExpressionArray() #DIV(2))?
}
void ExpressionArray(): {Token t;}
{
    ExpressionDot()
    [   <LSQUAREBRACKET> ExpressionAndMin() <RSQUAREBRACKET> #ARRAY
    ]
}

void ExpressionDot(): {Token t;}
{
    ExpressionNew()
   ( <DOT> #DOT(1)
        ( <LENGTH> #LENGTH(2)
          | <IDENTIFIER> <LPARENTHESES> [ ExpressionAndMin() (<COLON> ExpressionAndMin())*] <RPARENTHESES> #FUNCTION(2)
        )
    )?

}

void ExpressionNew(): {Token t;}
{
    Expression()
    [   ( <NEW> #NEW(1)
            ( <INTEGERLITERAL> <LSQUAREBRACKET> ExpressionAndMin() <RSQUAREBRACKET> #INTARRAY(2)
              | <IDENTIFIER> <LPARENTHESES> <RPARENTHESES>#CLASS(2)
            )
        )
    ]
}

void Expression(): {Token t;}
{
     <INTEGERLITERAL> #INT
    | <TRUE> #TRUE
    | <FALSE> #FALSE
    | <IDENTIFIER> #IDENTIFIER
    | <THIS> #THIS
    | <EXCLAMATION> ExpressionAndMin() #EXCLAMATION
    | <LPARENTHESES> ExpressionAndMin() <RPARENTHESES> #PARENTHESES
}

void Integer(): {Token t;}
{
    t=<INTEGERLITERAL>
}

void Method

