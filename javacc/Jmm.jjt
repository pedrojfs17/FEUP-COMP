options 
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Jmm)

import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.HashMap;
import pt.up.fe.comp.jmm.report.*;
import pt.up.fe.comp.jmm.analysis.*;

public class Jmm{

    public static HashMap<String, Integer> var = new HashMap<String, Integer>();
    public static int par_count=0;
    public static ArrayList<Report> reports = new ArrayList<Report>();
    public static void main(String[] args) throws ParseException {
        System.out.println("Parser for a file.");
        System.out.println("Write a file name");
        try{

            Jmm parser = new Jmm(System.in);
            SimpleNode root = parser.Program();

            root.dump("");
            System.out.println("Parsed.");
        } catch (Exception e) {
            System.out.println("Couldn't parse file");
            e.printStackTrace();
        }
    }

    public ArrayList<Report> getReports() {
        return reports;
    }

}



PARSER_END(Jmm)

SKIP : 
{
    " " | "\t" | "\n" | "\r" | <"//"(~["\r","\n"])*> | <"/*">: MLCOMMENT
}

<MLCOMMENT> SKIP :
{
    <"*/"> : DEFAULT
    | <~[]>
}

TOKEN : 
{
    <INTEGERLITERAL : (["0" - "9"])+ >
    | <IMPORT: "import">
    | <CLASS: "class">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <EXTENDS: "extends">
    | <RETURN: "return">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <ELIF: <ELSE> <IF>>
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <SOUT: "System.out.println">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <LENGTH: "length">
    | <LBRACKET: "{">
    | <RBRACKET: "}">
    | <LPARENTHESES: "(">
    | <RPARENTHESES: ")">
    | <LSQUAREBRACKET: "[">
    | <RSQUAREBRACKET: "]">
    | <COLON: ",">
    | <SEMICOLON: ";">
    | <DOT: ".">
    | <MINUS: "-">
    | <ADD: "+">
    | <EQ : "=">
    | <MULT: "*">
    | <DIV: "/">
    | <LESS: "<">
    | <EXCLAMATION: "!">
    | <AND: "&&">
    | <IDENTIFIER: ["a"-"z","A"-"Z","_","$"](["a"-"z","A"-"Z","0"-"9","_","$"])*>
}

SimpleNode Program() #PROGRAM : {}
{
    try {
        (ImportDeclaration())* ClassDeclaration() <EOF> { return jjtThis; }
    } catch(Exception e) {
        reports.add(new Report(ReportType.ERROR, Stage.SYNTATIC, getToken(0).beginLine, e.getMessage()));
        { return null; }
    }
}

void ImportDeclaration() #IMPORT: {Token t,t1;}
{
    <IMPORT> t=<IDENTIFIER> [SubImport() ] <SEMICOLON> {jjtThis.put("name",t.image);}
}

void SubImport() #SUB_IMPORT: {Token t;}
{
    <DOT> t=<IDENTIFIER> {jjtThis.put("name",t.image);} [SubImport() ]
}

void ClassDeclaration() #CLASS_DECLARATION: {Token t,t1;}
{
    <CLASS> t=<IDENTIFIER> {jjtThis.put("name",t.image);} [<EXTENDS> t1=<IDENTIFIER> {jjtThis.put("super",t1.image);} ]
    <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACKET>
}

void MethodDeclaration() #void: {}
{
    <PUBLIC> (MainDeclaration() | OtherMethodDeclaration())
}

void MainDeclaration() #MAIN: {}
{
    <STATIC> <VOID> <MAIN> <LPARENTHESES> <STRING> <LSQUAREBRACKET> <RSQUAREBRACKET> <IDENTIFIER> <RPARENTHESES> <LBRACKET>
    MethodBody()
    <RBRACKET>
}

void OtherMethodDeclaration() #METHOD_DECLARATION: {String str, str_2; Token t;}
{
    str=Type() {jjtThis.put("return",str);} t=<IDENTIFIER> {jjtThis.put("name",t.image);}<LPARENTHESES> [ (ParameterDeclaration() (<COLON> ParameterDeclaration())*) ]  <RPARENTHESES> <LBRACKET>
    MethodBody()
    <RETURN> str_2=ExpressionAnd()  {jjtThis.put("returned",str_2);} <SEMICOLON> <RBRACKET>
}

void ParameterDeclaration() #PARAMETER: {Token t; String str;}
{
    str=Type() t=<IDENTIFIER>{jjtThis.put("type",str); jjtThis.put("name",t.image);}
}

void MethodBody() #METHOD_BODY: {Token t;}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
}

void VarDeclaration() #VAR_DECLARATION: {Token t; String str;}
{
    str=Type() t=<IDENTIFIER>{jjtThis.put("name",t.image); jjtThis.put("type",str);} <SEMICOLON>
}

String Type() #void: {Token t;}
{
     t=<INT> [<LSQUAREBRACKET> <RSQUAREBRACKET> {return "int array";}]  {return "int";}
    | t=<BOOLEAN> {return "boolean";}
    | t=<IDENTIFIER> {return t.image;}
}

void Statement() #void: {Token t; String str,str_2;}
{
    <LBRACKET> (Statement())* <RBRACKET>
    | ifStatement()
    | whileStatement()
    | str = ExpressionAnd() [ <EQ> str_2 = ExpressionAnd() {jjtThis.put("variable",str); jjtThis.put("value",str_2);}#ASSIGNMENT] <SEMICOLON>
}

void ifStatement() #void: {Token t; String str;}
{
    <IF> <LPARENTHESES> str = ExpressionAnd() <RPARENTHESES> Statement() {jjtThis.put("condition",str);}#IF(1)
    <ELSE> Statement() #ELSE
}

void whileStatement() #WHILE: {Token t; String str;}
{
    try {
        <WHILE> <LPARENTHESES> {par_count++;} str=ExpressionAnd() {jjtThis.put("condition",str);} <RPARENTHESES> {par_count--;}
    } catch (ParseException e) {
        reports.add(new Report(ReportType.ERROR, Stage.SYNTATIC, getToken(0).beginLine, e.getMessage()));

        while(par_count>0) {
             error_skipto(RPARENTHESES);
             par_count--;
        }
    }

    Statement() #WHILE_BODY
}

// Operations

String ExpressionAnd() #void: {Token t; String str,str_2;}
{
    str= ExpressionLess()
    (<AND> str_2=ExpressionLess() {str+=" and "+str_2;})* {return str;}

}

String ExpressionLess() #void: {Token t; String str,str_2;}
{
    str= ExpressionAddSub()
    (<LESS> str_2=ExpressionAddSub() {str+=" less "+str_2;})* {return str;}

}

String ExpressionAddSub() #void: {Token t; String str,str_2;}
{
    str= ExpressionMultDiv()
    (   (t=<ADD>|t=<MINUS>) str_2=ExpressionMultDiv() {str+=t.image+str_2;})* {return str;}
}

String ExpressionMultDiv() #void: {Token t; String str,str_2;}
{
    str= ExpressionArray()
    (  (t=<MULT>|t=<DIV>) str_2=ExpressionArray() {str+=t.image+str_2;})* {return str;}
}
String ExpressionArray() #void: {Token t; String str,str_2;}
{
    str= ExpressionExc()
    [str_2 = Array() {str = str+str_2;}] {return str;}
}

String Array() #void: {Token t; String str;}
{
    <LSQUAREBRACKET> str=ExpressionAnd() <RSQUAREBRACKET> {return "["+str+"]";}
}

String ExpressionExc() #void: {Token t; String str;}
{
    (str= ExpressionDot()
    | (<EXCLAMATION> str=ExpressionExc()) {str="!"+str;}) {return str;}
}

String ExpressionDot() #void: {Token t; String str,str_2, str_3="";}
{
    str = Expression()
   ( <DOT>
        ( <LENGTH> {str_2="length";}
          | t=<IDENTIFIER> {str_2=t.image;} <LPARENTHESES> [str_3 = Params()] <RPARENTHESES>
        ){jjtThis.put("object",str); jjtThis.put("function",str_2); str=str+"."+str_2; if(str_3!="") jjtThis.put("params",str_3);}
        #OBJECT_METHOD
    )* {return str;}
}

String Params() #void: {String str, str_2;}
{
    str = ExpressionAnd() (<COLON> str_2= ExpressionAnd() {str+=","+str_2;})* {return str;}
}

String Expression() #void: {Token t; String str;}
{
     t=<INTEGERLITERAL>{return t.image;}
    | <TRUE> {return "true";}
    | <FALSE> {return "false";}
    | t=<IDENTIFIER>{return t.image;}
    | <THIS>{return "this";}
    | <LPARENTHESES> {par_count++;} str=ExpressionAnd() <RPARENTHESES> {par_count--;} {return "("+str+")";}
    | <NEW> (<INT> str=Array() {return "new int"+str;} | t=<IDENTIFIER> <LPARENTHESES> <RPARENTHESES> {return "new "+t.image;})

}

JAVACODE
void error_skipto(int kind) {
      Token t;
      do {
            t = getNextToken();
      } while (t.kind != kind && t.kind!=0);
}
